/** 
This file is part of LOVE-frontend.

Copyright (c) 2023 Inria Chile.

Developed for Inria Chile Tech Team.

This program is free software: you can redistribute it and/or modify it under 
the terms of the GNU General Public License as published by the Free Software 
Foundation, either version 3 of the License, or at your option) any later version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY
 WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR 
 A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with 
this program. If not, see <http://www.gnu.org/licenses/>.
*/

import React, { Component } from 'react';
import PropTypes from 'prop-types';
import DrawerMic from './Details/DrawerMic';
import Table from './Table/Table';
import styles from './Mics.module.css';

export default class Mics extends Component {
  static propTypes = {
    /* Array of Mics */
    mics: PropTypes.arrayOf(
      PropTypes.objectOf({
        /** Id unique for the reference to the mic */
        id: PropTypes.number,
        /** Name for the text in table and the title in the player component */
        name: PropTypes.string,
        /** Name of location for the grouping the microphones */
        location: PropTypes.string,
        /** String of the source url of the microphone */
        src: PropTypes.string,
        /** number in positive about the limit decibels for the alarm alert */
        dbLimit: PropTypes.number,
        /** minimum number for the range of spectrogram plot */
        minDecibels: PropTypes.number,
        /** maximum number for the range of spectrogram plot */
        maxDecibels: PropTypes.number,
      }),
    ),
    /** boolean value for the initial reproduce to all microphones */
    initialPlaying: PropTypes.bool,
  };

  static defaultProps = {
    mics: [],
    initialPlaying: true,
  };

  constructor(props) {
    super(props);
    this.state = {
      currentMic: null,
      infoPlot: null,
      alarms: {},
      viewInfo: false,
      records: [],
    };
  }

  componentWillUnmount = () => {
    this.closeMicDetails();
  };

  /**
   * Function to select a mic to show in details
   * @param {*} mic to be select
   */
  selectMic = (mic) => {
    if (this.state.currentMic) {
      let { id } = this.state.currentMic;
      this.closeMicDetails();
      if (id === mic.id) return;
    }
    this.setState({ currentMic: mic, viewInfo: true }, () => mic.selectMe());
  };

  /**
   * Method to set by the selected mic the necessary info to HeatMap component to plot
   * @param {*} data, info to plot
   */
  setInfoPlot = (data) => {
    this.setState((prevState) => ({ infoPlot: { ...prevState.infoPlot, ...data } }));
  };

  /**
   * Function to close Mic details and set null the current mic
   */
  closeMicDetails = () => {
    if (this.state.isRecording) this.record();
    if (this.state.isPlaying) this.play();
    this.state.currentMic?.selectMe();
    this.setState({ viewInfo: false, currentMic: null, infoPlot: null });
  };

  /**
   * Function to start or stop to record, using the current mic's recordFunc
   * @returns
   */
  record = () => {
    if (!this.state.currentMic) return;
    this.setState(
      (prevState) => ({ currentMic: { ...prevState.currentMic, isRecording: !prevState.currentMic.isRecording } }),
      () => this.state.currentMic?.recordFunc(),
    );
  };

  /**
   * Function to push a new record on records state
   * @param {*} id of the mic that push
   * @param {*} currentTime time of the record
   * @param {*} url, the blob url generated
   * @param {*} blob, the blob generated by record func
   */
  recordPush = (name, currentTime, url, blob) => {
    const newRecord = (prevRecords) => {
      prevRecords.push({ nameFile: name + '-' + currentTime.toString() + '.wav', url: url, blob: blob });
      return { records: prevRecords };
    };
    this.setState((prevState) => newRecord(prevState.records));
  };

  /**
   * Function to play o pause the current mic sound, using the current mic's recordFunc
   * @returns
   */
  play = () => {
    if (!this.state.currentMic) return;
    this.setState(
      (prevState) => ({ currentMic: { ...prevState.currentMic, isPlaying: !prevState.currentMic.isPlaying } }),
      () => this.state.currentMic.playFunc(),
    );
  };

  /**
   * Function to set the volume of current mic playing, using the setVolume function of microphone component
   * @param {float} value
   * @returns
   */
  setVolume = (value) => {
    if (!this.state.currentMic) return;
    this.state.currentMic.volumeFunc(value);
  };

  render() {
    const { mics, initialPlaying } = this.props;
    const drawerDetail = this.state.viewInfo ? styles.micDetails : styles.collapsedMicDetail;

    return (
      <div>
        <div className={styles.component}>
          {/* Mic Table */}
          <div className={styles.tableMics}>
            <Table
              mics={mics}
              selectMic={this.selectMic}
              recordPush={this.recordPush}
              setInfoPlot={this.setInfoPlot}
              initialPlaying={initialPlaying}
            />
          </div>
          <DrawerMic
            drawerDetailCss={drawerDetail}
            id={`${this.state.currentMic?.id}`}
            name={this.state.currentMic?.name}
            infoPlot={this.state.infoPlot}
            play={this.play}
            setVolume={this.setVolume}
            volume={this.state.currentMic?.volume ?? {}}
            isPlaying={this.state.currentMic?.isPlaying}
            isRecording={this.state.currentMic?.isRecording}
            dbLimit={`${this.state.currentMic?.dbLimit}`}
            record={this.record}
            records={this.state.records}
          />
        </div>
      </div>
    );
  }
}
